1. controller에서 repuest를 받게 되면 insert, update, delete, select를 진행하게 된다.
    만약, insert가 진행된다고 하면 데이터 베이스에 User 객체(예시)를 save 하게 되고, 이것은 JPA의 영속성 컨텍스트 부분의 1차 캐시에 User 객체가 쌓이게(만들어지게) 된다.
    이렇게 만들어진 객체는 데이터 베이스의 User에 추가된다. -> 이러한 과정(1차 캐시에 쌓인 것)을 '영속화'라고 한다. 또한, 영속화 된 객체를 데이터 베이스에 밀어 넣는 것을 'flush'라고 한다.
        조금 더 자세하게 말하자면 flush는 1차 캐시라는 창고에 데이터를 저장한 다음, 이 창고 안의 내용을 데이터 베이스에 옮겨놓는 과정을 말한다. 다만, flush 한 직후에는 1차 캐시에 있는 데이터를 지우지 않는다.
        이것은 select와 같은 명령어를 사용할 때, 영속화된 데이터를 필요로 한다면 데이터 베이스가 아닌 1차 캐시에서 들고와 사용하게 된다.
        이렇게하면 실제 데이터 베이스에 접근하지 않아도 되므로 부하가 줄어든다.

        update의 경우에는 우선, 데이터 베이스에 있는 정보를 select하여 1차 캐시에 영속화를 시키고 controller에 들고와 정보를 update한다.
        변경된 User의 값을 save하기 할때는 영속화 되어있는 정보와 update 시킨 정보의 id를 비교하여 id가 같으면 update한 정보를 영속화시킨다.
        이제 영속화된 정보를 flush하면 데이터 베이스에 update가 된 것이다.
            이러한 과정은 @Transactional이 retrun을 만나 종료 시에 자동으로 commit을 진행한다.

            update 과정에서 기존 데이터를 들고와 영속화하는 부분은 사진 1번의 User user = UserRepositroy.findById(id).orElseThrow(()->{} 부분이다.
            다음으로 user.setPassword(requestUser.getPassword());와 같이 set을 사용하여 내용을 변경하고, 종료 시 commit을 진행한다.
            commit이 진행되면 영속화 되어 있는 정보를 수정하여 그것을 기반으로 데이터 베이스를 저장하는 것이다.
                이처럼 변경된 내용을 감지하여 데이터 베이스를 수정하는 과정을 '더티체킹'이라고 한다.

2. 실제 update가 동작하는지 확인
    지금까지 사용했던 return의 null을 user로 변경(사진 2번)
    사진 4번과 같이 변경한 데이터를 작성한 후, send를 진행하면 사진 3번이 사진 5번과 같이 변경됨을 확인할 수 있다.
1. http 1.1이란?
    A와 B가 서로 통신을 하게 될 때, 이 통신은 Byte Stream(8bit)로 이뤄지며 A가 B로(A -> B) write, B에서 A로(B -> A) Read 할 수 있다. 이것이 일반적인 통신이다.
    (B가 서버(갑, 데이터를 가지고 있음)라고 한다면 서버(B)의 입장에서는 클라이언트(A)가 누구인지 궁금하지 않다. A가 B에게 요청(request)하게 된다면 B는 A에게 응답(response)하게 된다.)

    http 통신을 하게된다면 어떠한 약속이 필요한데 그 중에 http 1.1의 약속 중 통신 방법의 4가지 법칙(요청의 방법)이 있다.
        1-1. Get : 데이터를 받아올 수 있는 요청. - Select(A가 B에게 데이터를 요청하면 B는 그것에 대해 응답해야한다.)
        1-2. Post : 데이터의 추가를 요청. - Insert(회원가입을 하고 로그인을 하게 되면 웹브라우저에 내 정보를 서버에 넘겨줌.)
        1-3. Put : 데이터의 수정을 요청. - Update(회원정보의 수정 등)
        1-4. Delete : 데이터의 삭제를 요청. - Delete(회원정보의 삭제 등)

        이처럼 요청을 할 수 있지만 어떤 데이터를 요청한 것이지는 모른다. 그렇기 때문에 통신을 할 때
        '요청?how'와 같이 요청(Get, Post, put, Delete) 뒤에 '?'를 추가하여 요청할 데이터를 넣어준다.

2. stateless란?
    만약, A(클라이언트)와 B(서버)가 서로 통신을 하여 연결이 끊이지 않고 계속 유지되고 있다면, 다른 클라이언트가 B와 통신을 시도할 경우 서버에 부하가 생긴다.
    이렇게 끊이지 않고 지속되는 통신은 채팅에서 많이 사용한다.(stateful 방식)

    반면, http와 같은 데이터를 요청하는 경우에는 A의 요청을 응답한 B는 스트림 연결을 끊어버린다. 이러한 방식을 stateless라고 한다.

    stateful 방식의 경우는 연결이 지속되어 있기 때문에 세션(데이터 사용 권한 인증)이 유지되지만, stateless 방식의 경우는 연결이 끊기기 때문에 데이터를 요청할 때마다 세션 인증을 다시 진행해야한다.
    이것을 해결하기 위한 방법(security)는 차후에 알아보도록 하자.

3. MIME타입이란?
    클라이언트(A)가 서버(B)에게 Post 요청을 한다면 클라이언트는 수정할 내용을 헤더(Header)에는 수정할 내용을 담고 있는 경로(데이터를 설명해주는 내용), 바디(Body)에는 수정할 내용의 파일(실제 데이터)을 담아서 요청해야한다.
    이때의 헤더를 http 헤더, 바디를 http 바디라고 부른다.

    헤더에는 일반적으로 여러 가지 내용이 들어갈 수 있는데
        http 통신을 할 때, 패킷 스위칭 통신 방식을 사용한다. 이것을 이해하기 위해서는 서킷 스위칭 방식을 이해하고 있어야 한다.
            서킷 스위칭 방식(Circuit-Switching) : 간단한 예를 들자면 [a, b, c, d]라는 데이터가 존재할 때, A에서 B로 한 방에 실어서 전송을 한다.(A-> B)
                                                속도가 굉장히 빠른 대신에 다른 클라이언트가 전송을 하게되면 새로운 통신을 개방해야하기 때문에 비용이 많이 든다.(C -> B)
            패킷 스위칭 방식(Packet-Switching) : 서킷과 달리 [a, b, c, d]라는 데이터를 A에서 B로 전송할 때, [a], [b], [c], [d]로 분리하고 이때 분리된 하나하나의 데이터를 패킷이라고 부른다.
                                                A는 이렇게 잘개 쪼개진 패킷을 B에 전송하게 된다.
                                                이 경우에는 다른 클라이언트가 데이터를 전송하게 될 때, A가 전송한 경로를 따라 패킷을 전송한다.(C ->(A가 사용하던 경로) B)

                                                이렇게 패킷으로 분할된 데이터를 받게 된다면 B는 받은 패킷을 다시 조립해야한다.
                                                물론, 같은 경로를 이용하여 패킷을 받았기 때문에 무작위로 섞여있는 패킷을 분간하여 조립해야한다.

                                                이때, 수만가지의 경로를 통해 전달되는 패킷은 보낸 순서와 상관없이 도달할 수 있는데 이 순서를 정확하게 맞추기 위해 헤더에 데이터의 순서, 보낸 클라이언트 등의 정보를 포함한다.

                                                즉, 헤더에 담길 수 있는 내용은 어떤 것이든 들어갈 수 있기 때문에 작성 방식이 따로 정해져있다. 이 방식을 바로 'MIME' 라고 한다.

    MIME 타입이란 Multipurpose Internet Mail Extensions의 약자로 간단히 말하면 파일 변환을 의미한다.(클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘입니다.)
    웹에서 파일의 확장자는 별 의미가 없습니다. 그러므로, 각 문서와 함께 올바른 MIME 타입을 전송하도록, 서버가 정확히 설정하는 것이 중요합니다. 
    브라우저들은 리소스를 내려받았을 때 해야 할 기본 동작이 무엇인지를 결정하기 위해 대게 MIME 타입을 사용합니다.

        문법 : '/'로 구분된 두 개의 문자열인 타입과 서브타입으로 구성됩니다. (type/subtype)
                스페이스는 허용되지 않습니다. type은 카테고리를 나타내며 개별(discrete) 혹은 멀티파트 타입이 될 수 있습니다. subtype 은 각각의 타입에 한정됩니다.
                MIME 타입은 대소문자를 구분하지는 않지만 전통적으로 소문자로 쓰여집니다.

                ex) text/plain, text/html, image/jpeg, image/png, audio/mpeg, audio/ogg, audio/*, video/mp4, application/octet-stream

                * 타입을 모두 외울 필요 없이 https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types에서 찾아 사용.

4. Controller 생성 및 실습

    실습을 위해 test를 위해 만들었던 spring 패키지에서 새로운 클래스를 만든다.(사진 1번)
    이것이 컨트롤러가 되기 위해서 어노테이션이 필요하다.(사진 2번)
        - 사용자가 요청 -> 응답(HTML 파일) = @Controller
        - 사용자가 요청 -> 응답(Data) = @RestController
    정상적으로 작동하는지 확인하기 위해 사진 3번과 같이 요청 방식을 달리하여 작성.
    spring boot app을 실행하고 서버에 들어가면 입력해놓은 출력이 뜨는 것을 확인할 수 있는데, 여기서 작업 관리자에 들어가 Network에서 f5를 누르면 사진 4번과 같이 현재 페이지를 어떤 방식으로 요청했는지 볼 수 있다.
        - General(사진 5번)
            - Request Method : 요청 방식을 확인할 수 있다.
            - Status Code : 서버의 응답 상태를 확인할 수 있다.
        - Response Headers (서버가 어떻게 response 해주었나, 사진 6번)
            - Content-Type : 요청에 응답을 어떤 타입을 어떤 서브타입으로(type/subtype) 했으며, 그 응답이 무엇으로 인코딩 되어있는가.
        - Request Headers(내가 웹브라우저를 통해서 서버에게 요청할 때의 헤더, 사진 7번)

    get 요청과 달리 post 요청은 Whitelabel Error Page가 뜨며, 작업 관리자에서는 405로 나온다.(사진 8번)
    여기서 405 에러는 해당 메소드가 허용되지 않는다는 에러이다.(사진 9번)
    put과 delete 요청도 마찬가지로 에러 발생.(사진 10, 11번)

    즉, 인터넷 브라우저 요청은 무조건 get 요청밖에 할 수 없다.

    이런 에러를 무시하고 보기 위해 필요한 것이 postman이다.(사진 12번)
        - postman 활용(사진 13, 14, 15, 16번). 요청을 변경하기 위해서는 url 기입창 옆 request를 요청에 맞게 변경해줘야한다.

5. 실습
    java에서 변수는 거의 private로 만든다. (변수에는 다이랙트로 접근하지 않고 public의 메소드가 변수에 접근하여 수정할 수 있도록 만든다.)(사진 17번)
    그리고 이 변수에 접근할 수 있는 메소드를 만들기 위해서는 코드창에서 우클릭 - Source - Generate Gatters and Setters(사진 18번)에 들어가 메소드가 필요한 변수를 선택하면 된다.(사진 19, 20번)
    또한, 우클릭 - Source - Generate Constructor using Fields(사진 21번)에 들어가서 변수를 선택하면 생성자를 만들 수 있다.(사진 22번)

    Get 방식 :
        이제는 postman에서 http://localhost:8080/http/get?id=1 처럼 쿼리 스트링을 사용하여 id=1을 요청하게 되면 HttpControllerTest.java의 public String getTest()에서 
        public String getTest(@RequestParam int id)로 받을 수 있게 된다.(사진 25, 26번)
        만약, id와 다른 쿼리 스트링(username)을 동시에 사용하고 싶다면 &를 사용하면 된다.(코드에는 @RequestParam를 한 번 더 사용(여기서는 ','으로 연결))(사진 27, 28번)
            쿼리 스트링 :
                URL의 뒤에 입력 데이터를 함께 제공하는 가장 단순한 데이터 전달 방법이다.
                웹개발에서 데이터를 요청하는 방식 중 대표적인 것이 GET방식과 POST방식인데, 주로 GET방식으로 데이터를 요청할 때 쓰이는 방법이다.
                URL주소뒤에 물음표(?)를 붙이고 key1=value1&key2=value2...방식으로 데이터를 요청한다.

        이렇게 한 개씩 불러오는 방법 뿐만 아니라 이전에 만들어 놓은 Member class를 가지고 한 번에 불러오는 방법도 있다.(사진 29, 30번) -> 이러한 방식은 MessageConverter(스프링 부트)가 해준다.

        get 방식으로 데이터를 요청하는 쿼리 스트링밖에 없다.

    Post 방식 :
        java 코드는 get 방식과 똑같다.(사진 31번)
            5-1. 대신에 postman에서 Body 부분의 x-www-form-urlencoded에서 필요한 정보를 기입하면 받아올 수 있다.(사진 32번) -> 가장 기본적인 요청방식
            5-2. 두 번째 방식으로 postman에서 Body 부분의 raw를 사용하는 방식으로 raw에 들어가 "안녕"이라는 텍스트를 작성하면 400 에러가 뜨는 것을 확인할 수 있다.(사진 33번)
                이렇게 텍스트를 받기 위해서는 java 코드에서 public String getTest(Member m)이 아닌 다른 방식을 사용해야 하는데 public String getTest(String text)를 사용하면 null이 뜨는 것을 확인할 수 있다.(사진 34, 35번)
                그 이유는 @RequestBody가 빠졌기 때문이다.(사진 36번) 사진과 같이 정확한 코드를 작성하면 사진 37번과 같이 문제없이 "안녕"을 반환하는 것을 확인할 수 있다.
                이런 식으로 raw의 text를 사용했다는 것은 MIME 타입이 text/plain 이 된다.

                text가 아닌 json으로 받기 위해서는 java 코드를 다시 Member m으로 수정하고(사진 38번) postman의 Body - raw 에서 text를 json으로 바꾼 후, postman에 json 코드를 작성하면 된다.
                하지만 postman에서 json으로 작성한 결과 사진 39번처럼 생성자가 존재하지 않는다고 오류가 발생했다.
                이것은 기본 생성자를 추가하면 해결되는 문제로 java 코드창에서 우클릭 - Source - Generate Constructors from Superclass(사진 40번)에 들어가 기본 생성자를 만들면 된다.(사진 41번)
                그러면 postman의 응답이 정상적으로 이뤄진 것을 확인할 수 있다.(사진 42번)
    
    Put 방식 :
        Post 방식과 똑같다.(사진 43번)


JPA(Java Persistence API)란?
 1. JPA는 Java Persistence API 이다.
 2. JPA는 ORM 기술이다.
 3. JPA는 반복적인 CRUD 작업을 생략하게 해준다.
 4. JPA는 영속성 컨텍스트를 가지고 있다.
 5. JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다. (DB는 객체저장 불가능)
 6. JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다. (상속, 콤포지션, 연관관계)
 7. 방언 처리가 용이하여 Migration하기 좋음. 유지보수에도 좋음.
 8. JPA는 쉽지만 어렵다.

    1. Persistence(영속성). RAM은 휘발성이다. 즉, RAM에 저장된 데이터들은 컴퓨터가 꺼지는 순간 사라지게 된다. 이러한 데이터가 사라지지 않게 하기 위해서는 비휘발성인 하드디스크에 저장해야한다.
     이렇듯 어떤 데이터가 영구히 기록될 수 있도록 하는 것을 Persistence라고 한다. 
     java에서는 데이터를 DBMS에 저장하게 된다.

     즉, JPA는 DBMS에 데이터를 저장할 수 있게 만들어주는 API이다.

     그렇다면 API는 뭘까?
        API는 Application Programming Interface(애플리케이션 프로그램 인터페이스)로 인터페이스를 통해 프로그래밍을 하고, 그것으로 인해 프로그램이 만들어지는 것이다.

        여기서 인터페이스와 프로토콜을 비교해 볼 수 있는데 
            인터페이스는 A, B, C가 존재할 때, 만약, B의 힘이 가장 세다고 하면 B가 정한 법칙에 따라 A, C가 움직이는 것을 인터페이스라고 한다.
            즉, 프로그램을 만든 사람이 그 기능을 공유할 때, 자신만의 규칙을 만들어서 배포하는 것이라고 생각하면 편하다.

            이러한 인터페이스를 통해서 다른 개발자가 프로그래밍을 구상하면 그것은 API가 된다.(인터페이스는 상하관계가 존재하는 약속이다.)

            반대로 프로토콜은 A, B, C가 존재할 때, 이 셋의 권리가 동등하다.

     최종적으로 JPA는 java 프로그램을 사용할 때, 영구적으로 데이터를 저장하기 위해서 필요한 인터페이스이다.

    2. ORM(Object Relational Mapping)으로 쉽게 말해, 오브젝트를 데이터베이스에 연결하는 방법을 말한다.

     기본적으로 데이터베이스에 테이블을 만든 다음에 java에 class Team{int id;  String name;}과 같이 값을 input하거나 output 하여 사용한다.(TRM)
     하지만 ORM의 경우에는 위 과정을 반대로 java에 적힌 코드를 기반으로 데이터베이스에 코드를 만들 수 있다. 이때 필요한 것이 JPA가 가지고 있는 인터페이스이다.

    3. 데이터베이스의 자료를 java가 요청(connection)하게 된다면 데이터베이스는 권한을 확인한 후, 세션을 오픈하고 java는 쿼리를 전송하여 데이터를 불러오게 된다.
     하지만 java와 데이터베이스의 언어가 다르기 때문에 이전에 공부했던 MessageConverter와 마찬가지로 json으로 변경하여 들고 오게 된다.
     이러한 과정은 단순한 반복 로직이다. 이것을 줄이기 위여주는 것이 JPA이다.

     JPA를 사용하면 전송된 쿼리에 대한 응답이 있을 경우, 받은 데이터를 java 오브젝트로 바꾸고, 연결된 세션과 커넥터를 끊는 일련의 작업들을 함수화 하듯이 사용할 수 있게 된다.
     (CRUD, C : Insert, R : select, select All, U : update, D : Delete)

    4. context(컨텍스트)는 어떤 대상에 대한 모든 정보를 가지고 있는 것이다.

     java의 경우, 데이터베이스에 정보를 저장하기 위해서 가지고 있는 정보를 영속성 컨텍스트에 던진다. 다음으로 영속성 컨텍스트는 가져온 정보를 데이터베이스에 던진다. 이렇게하면 데이터베이스에 정보가 저장이 된다.
     여기서 영속성 컨텍스트에 저장된 내용을 삭제할 후, 그 상태로 데이터베이스에 던지게 되면 데이터베이스에도 그 정보가 삭제된다.
     즉, 영속성 컨텍스트에 있는 정보와 데이터베이스에 있는 데이터가 동기화되어 있는 것이다.

     반대로 데이터베이스에 있는 데이터를 java로 가져오기 위해서는 먼저 java에서 영속성 컨텍스트에 데이터를 넘겨받기 위해 요청을 하고, 영속성 컨텍스트에 요청받은 데이터가 없을 경우 데이터베이스에 요청을 하게 된다.
     이때, 데이터베이스의 type을 java object로 바꾸는 것은 영속성 컨텍스트에서 진행된다.
     이럴 경우에 java가 받아온 데이터와 영속성 컨텍스트가 가지고 있는 데이터, 데이터베이스가 가지고 있는 데이터는 모두 같은 것이다.

     이 상태에서 java에 있는 데이터를 변경하면 영속성 컨텍스트의 데이터가 변경이 되고, 데이터베이스에 commit을 실행하면 insert가 아닌 update가 진행된다.

    5. 간단하게 설명하자면 데이터베이스에 두 개의 테이블을 만들고 (Team(id, name, year을 들고 있다), Player(id, name, teamid를 들고 있다.)) java에서 가져오기 위해서는
     class Team{int id; String name; String year;}, class Player{int id; String name; int teamid}와 같이 이용해야하지만, java는 객체지향 프로그램(OOP)이기 때문에 
     class Player{int id; String name; Team teamid}와 같이 FK로 연결되어 있는 다른 테이블을 객체로 들고와 사용할 수 있다.(java는 객체 저장이 가능하다.)

    6. JPA는 class를 먼저 만들고 이 class를 기반으로 자동 생성된 DB table을 만든다.

    7. 스프링은 JPA를 통해서 DB에 접근한다. 만약, JPA가 무조건 Mysql만을 지원하는 것이 아닌 여러 가지의 DB를 지원한다.
     따라서 JPA는 추상화 객체(정해지지 않은 데이터베이스)를 가지고 DB에 접근한 후, 차후에 사용자가 원하는 DB를 설정할 수 있다.
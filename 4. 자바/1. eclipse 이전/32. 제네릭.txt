1. 제네릭(Generic)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다. 말이 어렵다. 아래 그림을 보자.(사진 1번)
 (클래스 외부에서 사용할 데이터 타입을 나중을 인스턴스를 생산할 때 확장하는 것.)

 사진 1번을 살짝 설명하자면 class person을 만들때 <> 안에 T를 입력하고 public T info;를 사용해 info의 데이터 타입을 T로 받는다.
 그 이후, person을 실제 사용할 때, <>를 이용하여 실제 사용할 데이터 타입(여기서는 String)을 넣어 기존 T로 정의된 타입을 String으로 바꿔주는 것이다.
 (사진 1번과 같이 한 번 제네릭을 설정하고(여기서는 T) 여러 개의 데이터 타입을(String, StringBuilder) 대체할 수 있다.)

 사진 1번을 코드로 적은 것이 사진 2번이다.

2. 사진 3번을 보면 StudentPerson와 EmployeePerson의 코드가 중복되는 것을 볼 수 있다.

3. 사진 4번을 보면 사진 3번에서 중복되는 코드를 Person으로 통합하고 인스턴스를 만들어 임의로 값을 받아보니("부장" 부분) 붉은 밑줄(오류(컴파일러))가 생기지 않는 것을 확인할 수 있다.
    하지만 직접 코드를 실행해보면 오류가 발생하게 된다. 이러한 상황을 '타입이 안정하지 않다.'라고 말한다.
    (여기서 문제의 "부장"이 들어갈 수 있었던 이유는 중복을 제거하기 위해 info의 데이터 타입을 object로 설정했기 때문이다.)

4. 위와 같은 컴파일러에서는 찾을 수 없는 오류를 예방하기 위해서 필요한 것이 제네릭이다.
 즉, 위 파일을 제네릭으로 작성하면 사진 5번과 같다.
  p1은 잘 동작할 것이다. 중요한 것은 p2다. p2는 컴파일 오류가 발생하는데 p2.info가 String이고 String은 rank 필드가 없는데 이것을 호출하고 있기 때문이다.

  여기서 중요한 것은 아래와 같이 정리할 수 있다.
    컴파일 단계에서 오류가 검출된다.(사진 5-1번)
    중복의 제거와 타입 안전성을 동시에 추구할 수 있게 되었다.

5. 클래스 내에서 여러개의 제네릭을 필요로 하는 경우가 있을 것이다. 이럴 경우에는 복수의 제네릭을 사용할 수 있다.
 사진 6번은 예외를 발생시키지만 문제는 다음 예제에서 처리하고 형식만 보자. 
 즉, 복수의 제네릭을 사용할 때는 <T, S>와 같은 형식을 사용한다. 여기서 T와 S 대신 어떠한 문자를 사용해도 된다. 
 이렇게 <T, S>의 형식으로 받았다면 데이터 형식을 다시 넣어줄 때에도 <EmployeeInfo, int>와 같은 형식으로 넣어준다.
 
 위에서 복수의 제네릭을 사용할 수 있다고 했지만 묵시적인 약속(convention)이 있기는 하다. 그럼 예제의 오류를 해결하자.

6. 사진 6번에서 오류가 발생한 이유는 제네릭에서는 참조형 데이터 타입만 받을 수 있는데 int라는 기본 데이터 타입을 받았기 때문이다.
 이러한 문제를 해결하기 위해서 java에서는 기본 데이터 타입을 마치 참조형 데이터 타입인것처럼 만들 수 있는 객체들을 제공한다. 이러한 클래스들을 wrapper class라고 한다.

 우선, 사진 6번에서 사용되는 int를 랩핑하기 위해서 Integer로 대신한다.
 그런 다음 Integer id = new Integer(1);로 인스턴스화를 시킨다.(기존의 int 형식으로 들어갔던 1을 wrapper class의 생성자로 들어가서 숫자 1을 의미하는 하나의 객체로 인스턴스를 만들었다.)
 (사진 7번)

7. 제네릭은 생략 가능하다. 아래 두 개의 코드가 있다. 이 코드들은 정확히 동일하게 동작한다. e와 i의 데이터 타입을 알고 있기 때문이다.(사진 8번)
 이것을 활용하면 
    사진 9번의 Person_6<EmployeeInfo_6, Integer> p1 = new Person_6<EmployeeInfo_6, Integer>(e, i); 부분은 사진 9-1번의 Person_7 p1 = new Person_7(e, i); 처럼,
    사진 9번의 p1.<EmployeeInfo_6>printInfo(e); 부분은 사진 9-1번의 p1.printInfo(e);처럼 생략이 가능해진다.
    (생략이 가능한 부분들은 Person_7(T info, S id)이나 EmployeeInfo_7 e = new EmployeeInfo_7(1);처럼 정의가 되어 있기 때문에 예측이 가능하기 때문이다.)
    (생략이 되면서 코드가 짧아져 가독성이 올라감)

8. 제네릭으로 올 수 있는 데이터 타입을 특정 클래스의 자식으로 제한할 수 있다.
 사진 10번을 보면 EmployeeInfo_8은 Info class를 상속받고, Person_8 class는 제네릭을 사용하였다. 여기서 제네릭 T에 들어오게 될 변수를 한정하기 위해 제네릭에 extends를 사용하여 info를 상속받는다.
 그렇게 하면 사진 10번과 같이 EmployeeInfo_8을 제네릭의 데이터 타입으로 할 경우, 문제없이 동작하지만,
 사진 11번과 같이 상속받은 타입이 아닌 것을 제네릭으로 받게 되면 에러가 발생한다.

 당연하게도 상속받을 info class를 abstract가 아닌 interface로 하여 extends 대신 implement로 받게 되어도 사용이 가능하다.
 대신에 제네릭 부분에서는 class Person_9<T extends Info_9>와 같이 extends로 받아와야한다.(사진 12번) 
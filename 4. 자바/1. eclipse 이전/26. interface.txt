1. 인터페이스(interface)는 다소 추상적인 개념이다. 

 인터페이스를 abstract, final와 함께 대표적인 규제라고 언급했던 적이 있다.

 인터페이스는 어떤 객체가 있고 그 객체가 특정한 인터페이스를 사용한다면 그 객체는 반드시 인터페이스의  메소드들을 구현해야 한다.
 만약 인터페이스에서 강제하고 있는 메소드를 구현하지 않으면 이 에플리케이션은 컴파일 조차 되지 않는다.

2. 간단하게 코드만 보자면 사진 1번과 같이 interface라고 정의된 I는 public void z();를 가져오지만 {}가 존재하지 않는다.(추상 클래스 안에 있는 추상 메소드와 같은 모습이다.)

 이 상태에서 class A implements I는 class A가 interface I를 구현(implements)하는 것이다.
 여기서도 추상 메소드와 같이 public void z() {}가 존재하지 않는다면 에러가 뜬다.

3. 인터페이스는 어떠한 프로그램을 개발할 때, 사용된다.

 예를 들자면 계산기를 사용하여 어떤 프로그램을 진행시켜야 할 때, 계산기를 만드는 개발자와 그 계산기를 사용하여 프로그램을 진행시키는 개발자가 동시에 일을 진행하기 위해 사용된다.

 사진 2번을 보면 CalculatorDummy라는 가상의 class를 만들어 놓고 그 안의 메소드는 public void setOprands(int first, int second, int third){}처럼 {}로 비워놓는다.(인터페이스를 사용하지 않은 상태이다.)
 그렇게 CalculatorDummy class를 사용할 때는 c.setOprands(10,20,30);와 같이 overriding을 사용하는 것이다.

 위와 같은 방법은 두 개발자 간의 의사소통에 문제가 발생할 경우 서로 다른 조건의 코드를 만들어 결합하기에 어려움이 생길 수 있다.

 이런 경우를 예방하기 위해 인터페이스가 존재하며 사진 3-2번과 같이 사용하여 서로의 코드가 꼬일 가능성을 줄여준다.(사진 3-2번의 코드를 실행시키기 위해서는 같은 패키지 안에 사진 3-1번 코드가 있어야한다.)

4. 인터페이스는 사진 4번의 class A implements I1, I2와 같이 하나의 클래스가 여러 개의 인터페이스를 구현할 수 있다.
 하지만 클래스 A는 메소드 x나 z 중 하나라도 구현하지 않으면 오류가 발생한다.

5. 또한 사진 5번과 같이 인터페이스는 상속이 가능하다.

6. 인터페이스의 맴버는 반드시 public이다. 사진 6번과 같이 public이 아닌 경우는 에러가 발생한다.

* abstract vs interface
    인터페이스와 추상 클래스는 서로 비슷한 듯 다른 기능이다. 인터페이스는 클래스가 아닌 인터페이스라는 고유한 형태를 가지고 있는 반면 추상 클래스는 일반적인 클래스다.
    또 인터페이스는 구체적인 로직이나 상태를 가지고 있을 수 없고, 추상 클래스는 구체적인 로직이나 상태를 가지고 있을 수 있다.
 
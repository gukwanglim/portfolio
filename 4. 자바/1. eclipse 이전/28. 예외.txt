1. 프로그래밍을 하면 많은 오류 상황에 직면하게 된다. 기능이 많아질수록 오류가 발생할 확률은 기하급수적으로 증가한다. 자연스럽게 오류를 잘 처리하기 위한 방법들이 필요해지게 된다.
 예외(Exception)란 프로그램을 만든 프로그래머가 상정한 정상적인 처리에서 벗어나는 경우에 이를 처리하기 위한 방법이다.

 컴퓨터 프로그램은 나누기를 할 때, 0으로 나누게 되면 에러를 띄우게 된다.(사진 1번)

2. 사진 1번과 같은 예러가 발생했을때, 이것을 프로그램 상에서 에러를 띄우지 않고 넘기기 위해서는 사진 2번과 같이 try_catch 구문으로 예외처리를 해줘야 한다.
 즉, try 구문에서 벗어난 코드는 catch의 메개변수로 받은 Exception 타입의 e를 받아 따로 오류 표시를 해주는 것이다.

3. 예외의 핵심은 뒷수습이다. 하지만 제대로 된 수습은 대단히 어려운 문제이다.
 사진 3번과 같이 어느 부분에서 어떤 방식으로 오류가 발생한 것인지 정확히 띄울 수 있는 명령어가 존재하며 try 구문이 끝난 후에는 코드의 실행이 끝나는 것이 아니라 그 다음에 이어질 코드가 실행된다.

4. 사진 4번은 배열에 관한 에러로 배열의 범위 밖의 데이터를 불러올 때 발생한다.
 또한, 사진 4-2번과 같이 배열의 범위를 알맞게 설정한다 하여도 수식에서 문제가 발생할 경우 에러가 띄워진다.

 이처럼 수식 에러와 배열 에러는 비슷한 형식으로 표현이 된다. 그렇다면 서로 다른 에러를 다른 방식으로 표현하는 방법은 무엇일까?
 그 방법은 사진 5번과 같이 발생하게 되는 각각의 에러를 데이터 타입으로 설정하여 catch 구문을 돌리면 된다.

5. finally는 try 구문에서 예외가 발생하는 것과 상관없이 언제나 실행되는 로직이다.(사진 6번)

 finally는 주로 데이터 베이스에서 데이터를 가져오는 과정에 에러가 발생할 경우, 데이터 베이스와의 연결을 끊어주는 과정에서 사용된다.

6. API를 사용할 때 설계자의 의도에 따라서 예외를 반드시 처리해야 하는 경우가 있다. 
 사진 7번을 보면 out.txt라는 파일이 존재하지 않을 경우 발생하는 에러이다. 또한, IOException을 처리하고 있지 않다는 에러도 같이 있다.

 eclipse를 사용했을 경우 문제를 해결하기 위한 가장 간단한 방법은 붉은색 밑줄이 그어진 부분에 마우스를 올렸을 때, 나타나는 해결방안을 이용하는 것이다.(사진 7-1번/ 여기서는 아래줄을 사용.(사진 7-2번))
 만약, 붉은 밑줄이 그어져 있는 이유를 자세히 알고 싶다면 그 부분에 커서를 두고 F1키를 눌러 도움말을 확인할 수 있다.(사진 7-3번) 
 여기서 사진 7-3번의 밑줄을 따라 들어가보면 내가 알고 싶은 부분의 더욱 정확한 설명이 나오는데 그 중에서 throws라는 부분은 에러를 발생할 수 있으니 예외처리를 강제하라는 뜻이 된다.(사진 7-4번)

7. 위 사진 7-4번에서 보이는 throws의 사슬(연결)에 대해서 알아야 할 필요성이 있는데, throw는 보다 상위 클래서에서 예외처리를 하지 않고 하위 클래스에 넘기는 상황을 말한다.

8. 사진 8-1번을 보면 void run() throws FileNotFoundException{}에서 FileNotFoundException라는 에러를 자신의 하위 클래스에 예외처리를 넘겨주는 것을 강제하게 된다.
 그렇기 때문에 현재 class에서 예외처리를 하게된 지금의 상황(사진 8-1번)에서는 이 class의 하위 클래스에 에러가 뜬 모습을 볼 수 있다.
 이 문제를 해결하기 위해서는 상위 클래스의 예외처리를 지우고 하위 클래스에 예외처리를 넣으면 된다.(사진 8-2번)

9. 지금까지 API의 소비자로서 API 측에서 던지는 예외를 처리하는 방법을 알아봤다. 이번에는 API의 생산자로서 소비자들에게 API를 제공하는 입장에 서보자.
 소비자의 입장에서는 문제가 발생하는 시점에서부터 그 문제를 알려주고 그러한 행동을 하지 못하게 규제하는 것이 좋다. 즉, 0으로 나누기 전에 인자에 0이 들어가지 못한다는 사실을 알려주는 것이다.(사진 9번, 9-1번)

 물론, 사진 9번은 이런 식으로 예외처리를 할 수 있다는 것을 보여주는 예시이다. 실제 프로그램을 만들때는 9-1번과 같이 예외의 범위를 구체화하여 적용하는 것이 좋다.

 여기서 throws와 throw의 쓰임을 알 수 있는데,
    throws는 상위 클래스에서 하위 클래스에 예외처리를 넘길 때 사용되며,
    throw는 상위 클래스에서 받은 예외처리를 실행할 때 사용된다.

 또한, 사진 9-2번처럼 main 메소드에 try_catch 구문을 넣어 사용하게 된다면 더욱 소비자의 입장에서 더욱 깔끔하게 사용할 수 있게 된다.

 쉽게 말해, 지금까지 했던 예외처리는 프로그램 상에서 떠오른 오류 메시지를 그대로 가져왔다면,
 사진 9-2번에서는 프로그램 상의 오류 메시지가 떠오르는 것을 입력으로 받아 소비자가 보기 편하게 출력하는 것이다.

10. java는 기본적으로 예외를 제공한다. 이러한 예외들은 자바 가상머신이 사용하기도 하고 또 응용 프로그램 개발자가 사용할 수도 있다. 기본적으로 제공되는 어떤 예외들이 있는지를 파악하고 적당한 예외를 사용하는 것은 중요한 문제다.
 클래스 Exception을 API 문서에서 찾아보고 그 하위 클래스로 어떤 것들이 있는지 살펴보는 것도 도움이 된다.(기본적으로 알면 좋은 예외 사진 10번) 

11. 이번에는 예외처리의 강제가 되는 메소드와 그렇지 않은 메소드에 대해 알아보자.

 사진 11번을 보면 throwArithmeticException 메소드의 경우, throw new ArithmeticException();처럼 문제없이 사용할 수 있는 반면,
 throwIOException 메소드의 경우는 throw new IOException();에 붉은 밑줄이 그이면서 오류가 발생하는 것을 볼 수 있다.

 이러한 오류를 해결하기 위해서는 사진 11-1번과 같이 예외처리를 실행하거나, 하위 클래스로 예외를 전가시키는 방법이 있다.

 이렇게 어떤 것은 예외처리를 강제하고 어떤 것은 예외처리를 하지 않아도 오류가 발생하지 않는 이유는 무엇일까?
    우선, 오류가 발생하지 않은 ArithmeticException의 도움말을 살펴보자.
     사진 12번을 보면 ArithmeticException는 Throwable이라는 상위 클래스를 가지고 있다.
     Throwable 클래스는 getMessage(), printStackTrack(), toString() 등의 메소드를 사용할 수 있고, 이러한 특성으로 인해 예외의 정보를 담고 던저줄 수 있게 된다.
     또한, ArithmeticException는 Exception이라는 포괄적인 예외처리의 상위 클래스를 가지고 있다.(사진 12-1번)

     이런 예외 클래스의 전체적은 도면은 사진 12-2번과 같다.

     여기서 Error의 경우는 그 애플리케이션이 동작하는 가상머신에 문제가 생겼을 때 발생하는 예외다. 애플리케이션을 구동시키기에는 메모리가 부족한 경우가 이에 속한다. 
      이런 경우는 애플리케이션 개발자가 할 수 있는 것이 없다. 따라서 예외처리를 하지 말고 그냥 에러로 인해서 애플리케이션이 중단되도록 내버려둔다.
      대신 자신의 애플리케이션이 메모리를 과도하게 사용하고 있다면 로직을 변경하거나 자바 가상머신에서 사용하는 메모리의 제한을 변경하는 등의 대응을 한다.

    결국 우리의 관심사는 Exception 클래스와 RuntimeException 클래스로 좁혀진다.

    다시 처음으로 돌아가 ArithmeticException와 IOException을 비교해보자.
        ArithmeticException는 RuntimeException를 상위 클래스로 두고 있으며, IOException은 RuntimeException를 포함하고 있지 않다.
        이처럼 RuntimeException 클래스를 포함하고 있는 것을 unchecked Exception이라 하고, RuntimeException 클래스를 포함하지 않은 것을 checked Exception이라 한다.

        조금 더 정확히 말하자면 unchecked의 경우에는 예외를 처리할 필요가 없으며, checked의 경우에는 throw나 throws를 사용해서 예외를 처리해야한다.

 때문에 ArithmeticException는 예외처리가 필요 없으며,
 IOException는 예외처리를 강제해야하는 것이다.

12. 표준 예외 클래스로도 많은 예외 상황을 표현할 수 있다. 하지만 그렇지 않은 경우도 있을 것이다. 이런 때는 직접 예외를 만들면 된다.
 예외를 만들기 전에 해야 할 것은 자신의 예외를 checked로 할 것인가? unchecked로 할 것인가를 정해야 한다. 그 기준은 모호한 문제다. 하지만 기준이 없는 것도 아니다.

 API 쪽에서 예외를 던졌을 때 API 사용자 쪽에서 예외 상황을 복구 할 수 있다면 checked 예외를 사용한다. checked 예외는 사용자에게 문제를 해결할 기회를 주는 것이면서 예외처리를 강제하는 것이다. 
 하지만 checked 예외를 너무 자주 사용하면 API 사용자를 몹시 힘들게 할 수 있기 때문에 적정선을 찾는 것이 중요하다.

 사용자가 API의 사용방법을 어겨서 발생하는 문제거나 예외 상황이 이미 발생한 시점에서 그냥 프로그램을 종료하는 것이 덜 위험 할 때 unchecked를 사용한다.


 사진 14번을 보면 새로운 class인 DivideException를 만들어 RuntimeException를 상속받고 내가 원하는 동작을 수행할 수 있도록 코드를 짠 후, throw new DivideException("0으로 나누는 것은 허용되지 않습니다.");와 같이 사용한다.
  이렇게하면 에러 메시지에 우리가 설정할 것과 같이  org.opentutorials.javatutorials.exception.DivideException 에러를 반환받을 수 있다.

13. 12번과 달리 checked class로 상속을 받을 경우에는 예외처리를 강제하기 때문에 try_catch 구문으로 코드를 수정해야한다.(사진 15번)

14. 더 나아가 사진 16번처럼 입력받은 left와 right의 값을 받아와 새로 만든 class DivideException_3에 넣어놓고 문제가 발생했을 때, 내가 적은 내용까지 확인할 수 있다.
 (이 방법은 굳이 사용하지 않는 방법이긴 하나 우리가 새로운 예외처리 클래스를 만들고 그것에 대해 활용할 때는 좋은 방식이다.)
 (또한, 이런 식으로 try_catch 구문을 이용하여 사용자의 편의에 맞춰 출력을 하게 만들어 주기 위해서는 Calculator_7 class에서 예외처리를 끝내는 것이 아니라 throws로 새로 만든 class를 받고 throw로 예외처리에 들어갈 코드를 작성한 후,
  화면에 출력할 수 있는 main 메소드에서 try_catch 구문을 이용하여야 한다.)
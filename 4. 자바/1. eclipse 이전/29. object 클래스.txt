1. 자바에서 상속이란 필수적이다. 상속하건 하지 않았건 기본적인 상속을 하게 된다.
 그렇기 때문에 사진 1번과 1-2번의 코드는 서로 같은 코드라고 말할 수 있다.

 자바에서 모든 클래스는 사실 Object를 암시적으로 상속받고 있는 것이다. 그런 점에서 Object는 모든 클래스의 조상이라고 할 수 있다.
 그 이유는 모든 클래스가 공통으로 포함하고 있어야 하는 기능을 제공하기 위해서다.

2. toString은 객체를 문자로 표현하는 메소드이다.
 사진 2-1번과 2-2번은 .toString()의 유무에 차이가 있지만, 실행되는 것은 같다. 이렇게 toString()이라는 메소드를 호출할 수 있는 이유는 Calculator라는 class가 Object를 자동으로 상속 받았기 때문이다.
 (물론, Object를 자동으로 상속받는 것과 같이 c1(객체)에 담겨있는 정보를 문자열의 형태로 출력할 때 .toString() 또한 자동으로 실행이 된다.)

 이처럼 toString()으로 호출할 수 있다면 overriding도 가능하다.(사진 2-3번/ 물론, .toString()을 사용하지 않아도 똑같은 출력을 볼 수 있다.)

3. equals는 객체와 객체가 같은 것인지를 비교하는 API이다. 객체 간에 같고 다름은 필요에 따라서 달라질 수 있기 때문이다.
 사진 3번을 보면 s1과 s2에 저장된 문자열이 같아도 false를 반환하는 것을 볼 수 있다.(두 개의 객체가 서로 다른 값이라고 인지를 한다.)

 하지만, 두 개의 객체의 상태가 서로 같다면 true를 반환하게 만들 수도 있다.(사진 3-2번)
 여기서 Student _obj = (Student)obj; 부분은 Object가 Student보다 상위 클래스이기 때문에 자식 클래스에 할당될 수 없어 강제로 형 변환을 시키기 위해서 (Student)를 사용한다.

 다른 방법으로는 Student class에 커서를 올려놓고 마우스 우클릭 - Source - Generate hashCode() and equals()를 선택하면(사진 4번) 창이 하나 뜨는데(사진 4-2번) equals를 실행하고 싶은 멤버를 선택하고 실행하면 
 자동으로 코드가 작성되는 것을 볼 수 있다.(사진 4-3번)

 이때 ==와 equals가 있는데 equals를 사용할 때에는 주로
    1. 객체 간에 동일성을 비교하고 싶을 때는 ==를 사용하지 말고 equals를 이용하자.
    2. equals를 직접 구현해야 한다면 hashCode도 함께 구현해야 함을 알고 이에 대한 분명한 학습을 한 후에 구현하자.
    3. equals를 직접 구현해야 한다면 eclipse와 같은 개발도구들은 equals와 hashCode를 자동으로 생성해주는 기능을 가지고 있다. 이 기능을 이용하는 것을 고려해보자.(사진 4-3번)
    4. 그 이유가 분명하지 않다면 비교 연산자 == 은 원시 데이터형을 비교할 때만 사용하자.
    (원시 데이터 형(Primitive Data Type)이란 자바에서 기본적으로 제공하는 데이터 타입으로 byte, short, int, long, float, double, boolean, char가 있다. 이러한 데이터 타입들은 new 연산자를 이용해서 생성하지 않아도 사용될 수 있다는 특징이 있다.)

4. finalize는 객체가 소멸될 때 호출되기로 약속된 메소드이다. 많은 자바의 전문가들이 이 메소드의 사용을 만류하고 있다.

 이 메소드 보다는 가비지 컬렉션(garbage collection)에 대해서 알아보자. 인스턴스를 만드는 것은 내부적으로는 컴퓨터의 메모리를 사용하는 것이다. 여기서 말하는 메모리는 RAM을 의미한다.
 램은 가장 빠른 저장 장치이기 때문에 컴퓨터 프로그램들은 이 램에 저장된 후에 동작하게 된다.
 하지만 램은 가격이 비싸고 용량이 적기 때문에 램은 컴퓨터에서 가장 소중한 저장 장치라고 할 수 있다.
 그러므로 램의 적게 사용하는 프로그램이 좋은 프로그램이다.
 그런 이유로 많은 프로그래밍 언어들이 램을 효율적으로 사용하기 위해서 더 이상 사용하지 않는 데이터를 램에서 제거할 수 있는 방법들을 제공한다.

 하지만 자바에서는 이러한 방법이 제한적으로 제공되고 있는데 그것은 자동으로 해주기 때문이다. 이 작업을 자동화한 것을 가비지 컬렉션이라고 한다.
 이를테면 어떤 인스턴스를 만들었고, 그것을 변수에 담았다.
 그런데 그 변수를 사용하는 곳이 더 이상 없다면 이 변수와 변수에 담겨있는 인스턴스는 더 이상 메모리에 머물고 있을 필요가 없는 것이다.
 자바는 이를 감지하고 자동으로 쓰지 않은 데이터를 삭제한다. 따라서 개발자가 사용하지 않는 데이터를 직접 삭제하는 작업을 하지 않아도 되는 것이다.
 이것은 어려운 메모리 관리로부터 개발자들의 부담을 경감시킨 도약이라고 할 수 있다.

 그럼에도 불구하고 좋은 에플리케이션을 만들기 위해서는 가비지 컬렉션에 대한 이해는 필요하다.
 
 참고 링크 : https://d2.naver.com/helloworld/1329

5. clone은 복제라는 뜻이다. 어떤 객체가 있을 때 그 객체와 똑같은 객체를 복제해주는 기능이 clone 메소드의 역할이다. 
 python의 copy와 달리 clone은 복제하기 위한 클래스가 복제 가능한 것이라는 사실을 구분시켜야한다. 즉, 사진 5번과 같이 class Student_3 implements Cloneable을 사용해야지만 clone을 사용할 수 있다.
 그런데 Cloneable을 ctrl+좌클릭을 하여 자세히 보게되면 아무것도 들어있지 않은 빈 껍데기라는 사실을 알 수 있다.(사진 5-1번) 따라서 Cloneable은 단순히 clone을 사용 가능하다고 말해주는 역할일 뿐이다.

 또한, 이렇게만 하여 clone을 실행할 수 있는 것이 아니고, protected Object clone() throws CloneNotSupportedException { return super.clone(); }처럼 Object를 상속받아 clone을 사용해야한다.
 (여기서 clone은 checked class로 예외처리를 이 코드에서 끝내거나 하위 클래스로 넘겨야한다.)